\documentclass[11pt,a4paper,oneside]{article}

\usepackage[english,russian]{babel}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{expdlist}
\usepackage{mfpic}
\usepackage{comment}
\usepackage{listings}
\usepackage{epigraph}
\usepackage{url}
\usepackage{array}
%include polycode.fmt
%options ghci
%format Var v = v
%format App x y = x y
%format Lam x v = "\lambda" x "\to" v
%format if' = if
%format then' = then
%format else' = else

\long\def\ignore#1{}

\begin{document}

\ignore{
\begin{code}
import Prelude hiding (id, succ, fst, snd, pred)
\end{code}
}

\section{Лямбда-исчисление}

\emph{Лямбда-исчисление}~--- формальная система, придуманная в 1930-х годах 
Алонзо Чёрчем. Лямбда-функция является, по сути, анонимной функцией.
Эта концепция показала себя удобной и сейчас активно используется во многих
языках программирования.

Более формально, \emph{лямбда-функцию} (или, \emph{лямбда-терм}) можно задать 
следующей грамматикой:

$$
\begin{array}{r c l}
\langle Term \rangle & ::= & \langle Variable \rangle \\
                       & || & \langle Term \rangle \langle Term \rangle \\
                       & || & \lambda \langle Variable \rangle \to \langle Term \rangle\\
                       & || & ( \langle Term \rangle )\\
\langle Variable \rangle & ::= & \langle Char \rangle *\\
\end{array}
$$

В первом случае функция является просто переменной. 
Во втором происходит \emph{аппликация} (\emph{применение}) одной функции к другой.
Это аналогично вычислению функции-левого операнда на аргументе-правом операнде.
В третьем~--- \emph{абстракция} по переменной. В данном случае происходит 
создание функции одного аргумента с заданными именем аргумента и телом функции.

Рассмотрим, например, функцию |id = \x -> x|. Эта функция принимает аргумент и 
возвращает его неизменённым. Например, 
|id 2 == | \eval{id 2}. Аналогично, |id y == y|. 

Ещё один пример функции: |sum = \x -> \y -> x + y|. Эта функция двух аргументов,
которая возвращает их сумму. Правда, здесь мы немного вышли за написанную выше грамматику.
Ну да ладно. |sum 2 3 == 5|

\subsection{Приоритет операций}
\begin{itemize}
\item Применение левоассоциативно: |x y z w == ((x y) z) w|
\item Аппликация забирает себе всё, до чего дотянется:\\ 
    |\x -> \y -> \z -> z y x == \x -> (\y -> (\z -> ((z y) x)))|
\item Скобки играют привычную роль группировки действий
\end{itemize}

\subsection{Свободные и связанные переменные}
\emph{Связанными} переменными называются все переменные, по которым выше в 
дереве разбора были абстракции. Все остальные переменные называются свободными.

Например, в |\x -> \y -> x|, |x| связана, а |y|~--- свободна. А в |\y -> x (\x -> x)|
в своём первом вхождении переменная |x| свободна, а во втором~--- связана.

Рассмотрим функции |\y -> y| и |\x -> y|. В первой из них при взгляде на |y|
понятно, что она имеет отношение к переменной, по которой производилась 
абстракция. Если по одной и той же
переменной абстракция производилась более одного раза, то переменная связана
с самым поздним (самым нижним в дереве разбора) абстрагированием. Например, в
|\x -> \x -> \y -> \x -> x|, переменная |x| связана с самой правой абстракцией 
по |x|.

\subsection{$\alpha$-конверсия}

Рассмотрим функции |(\x -> x) z| и |(\y -> y) z|. Интуитивно понятно, что они 
являются одинаковыми. 

\emph{$\alpha$-конверсия}~--- переименование связанной переменной. Выражение
|\x -> f| можно заменить на |\y -> f[x := y]|, если |y| не входит свободно в |f|,
где $f[x:=y]$ означает замену всех свободных вхождений $x$ в $f$ на $y$.

Функции, получающиеся одна из другой с помощью $\alpha$-конверсий, называются 
\emph{$\alpha$-эквивалентными} и обозначаются $f \equiv_\alpha g$.

Функции |\x -> \y -> x y z| и |\a -> \x -> a x z| являются $\alpha$-эквивалентными,
а |\x -> \y -> y z| и |\y -> \x -> y z|~--- нет.

\subsection{$\beta$-редукция}
$\beta$-редукция олицетворяет идею счёта значения функции. Выражение вида 
|(\x -> f) y| можно заменить на $f[x := y]$, где $f[x:=y]$, как и ранее, означает
замену всех свободных вхождений $x$ в $f$ на $y$.

Через $f \to_\beta g$ обозначают сведение $f$ к $g$ с помощью одной $\beta$-редукции.
А через $f \to_\beta^* g$~--- за ноль или более.

\subsection{$\eta$-редукция}
Рассмотрим выражение вида |\x -> f x|. Если подставить в эту функцию значение 
$y$, то получим: $(\lambda x \to f x) y \to_\beta f y$. Но если просто подставить
$y$ в $f$, то получится то же самое. 

$\eta$-редукция~--- преобразование |\x -> f x| в $f$.

\section{Нотация Де Брюина}
Существует также альтернативное эквивалентное определение $\lambda$-исчисления.
В оригинальном определении для обозначения переменных использовались имена,
и была проблема с тем, что не были запрещены одинаковые имена в разных
абстракциях. 

От этой проблемы можно избавиться следующим образом. Вместо имени переменной 
будет храниться натуральное число~--- количество абстракций в дереве разбора,
на которое нужно подняться, чтобы найти ту лямбду, с которой данная переменная 
связана. В данной нотации получаются несколько более простые определения 
свободных переменных и $\beta$-редукции. 

Переменная называется свободной, если ей соответствует число, которое больше
количества абстракций на пути до неё в дереве разбора.

При $\beta$-редукции же нужно будет ко всем свободным переменным заменяющего 
дерева при каждой замене прибавить число, равное разницы уровней раньше и сейчас.
Это будет соответствовать тому, что эта переменная продолжит <<держаться>> за
ту же лямбду, что и раньше.

\section{Нумералы Чёрча}

\subsection{Определение}
Введём на основе лямбда-исчисления аналог натуральных чисел, основанный на идее, 
что натуральное число~--- это или ноль, или увеличенное на единицу натуральное 
число.

\begin{code}
zero  = \s -> \z -> z
one   = \s -> \z -> s z
two   = \s -> \z -> s (s z)
three = \s -> \z -> s (s (s z))
\end{code}

Каждое число будет функцией двух аргументов: какой-то функции и начального значения.
Число $n$ будет $n$ раз применять функцию к начальному значению и возвращать 
результат. Если такому <<числу>> дать на вход функцию $(+1)$ и $0$ в качестве 
начального значения, то на выходе как раз будет ожидаемое от функции число:
|three (+1) 0 == | \eval{three (+1) 0}.

\subsection{+1}
Функция, прибавляющая 1 к числу, должна принимать первым аргументом число.
Но число~--- функция двух аргументов. Значит, эта функция должна принимать три
аргумента: <<число>> $n$, которое хочется увеличить, функция, которую надо будет
$n+1$ раз применить, и начальное значение.

\begin{code}
succ = \n -> \s -> \z -> s (n s z)
\end{code}

Здесь $n s z$~--- $n$ раз применённая к $z$ функция $s$. Но нужно применить $n+1$ 
раз. Отсюда $s (n s z)$.

\subsection{Сложение}
Сложение двух чисел похоже на прибавление единицы. Но только надо прибавить не
единицу, а второе число.

\begin{code}
plus = \n -> \m -> \s -> \z -> n s (m s z)
\end{code}

 <<$n$ раз применить $s$ к применённому $m$ раз $s$ к $z$>>

|(plus three three) (+1) 0 == | \eval{(plus three three) (+1) 0}

\subsection{Умножение}
Умножение похоже на сложение, но прибавлять надо не единицу, а второе число.
Или, в терминах нумералов Чёрча, в качестве применяемой несколько раз
функции должна быть не $s$, а функция, применяющая $n$ раз $s$.

\begin{code}
mult = \n -> \m -> \s -> \z -> n (m s) z
\end{code}

Здесь |m s|~--- функция, которая $m$ раз применит $s$ к тому, что дадут ей на 
вход. С помощью $\eta$-редукции можно немного сократить эту формулу

\begin{spec}
mult = \n -> \m -> \s -> n (m s)
\end{spec}

|(mult three three) (+1) 0 == | \eval{(mult three three) (+1) 0}

\subsection{Возведение в степень}
It's a kind of magic

\begin{code}
power = \n -> \m -> m n
\end{code}

|(power three (succ three)) (+1) 0 == | \eval{(power three (succ three)) (+1) 0}

\subsection{Логические значения}
\begin{code}
true = \a -> \b -> a
false = \a -> \b -> b
\end{code}

Функции двух аргументов, возвращающие первый и второй, соответственное, аргументы.
Забавный факт: $false \equiv_\alpha zero$. Эти функции сделаны такими для того, 
чтобы красиво написать функцию $if$:

\begin{code}
if' = \p -> \t -> \e -> p t e
\end{code}

Если ей в качестве первого аргумента дадут $true$, то вернётся $t$, иначе~--- $e$.

Ещё одной важной функцией является функция проверки, является ли число нулём:

\begin{code}
isZero = \n -> n (\c -> false) true
\end{code}

Функция выглядит несколько странно. |\c -> false|~--- функция, которая независимо
от того, что ей дали на вход, возвращает $false$. Тогда, если в качестве $n$
будет дан ноль, то функция, по определению нуля, не выполнится ни разу, и будет
возвращено значение по умолчанию $true$. Иначе же функция будет запущено, и 
вернётся $false$.

\subsection{Пара}

\begin{code}
pair = \a -> \b -> \t -> t a b
fst = \p -> p true
snd = \p -> p false
\end{code}

Функция $pair$ принимает два значения и запаковывает их в пару так, чтобы к
ним можно было обращаться по $fst$ и $snd$. В $fst$ и $snd$ вместо $t$ в $pair$
будет подставлено $true$ или $false$, возвращающие, соответственно, первый и
второй аргументы, то есть $a$ или $b$, соответственно.

\subsection{Вычитание}
В отличие от всех предыдущих функций, вычитание для натуральных чисел определено
только в случае, если уменьшаемое больше вычитаемого. Положим в противном случае
результат равным нулю. Пусть уже есть функция, которая вычитает из числа единицу.
Тогда на её основе легко сделать, собственно, вычитание.

\begin{code}
minus = \n -> \m -> m pred n
\end{code}

 <<$m$ раз вычесть единицу из $n$>>.

Осталось, собственно, функция для вычитания единицы. Однако, это не так просто,
как может показаться на первый взгляд. Проблема в том, что, имея функцию, которую
нужно применить для того, чтобы продвинуться вперёд, продвинуться назад будет
проблематично. Если попробовать воспользоваться идеей о том, чтобы, начав от 
нуля, идти вперёд, и пройти на один шаг меньше, то будет не очень понятно, как
же остановиться ровно за один шаг до конца. Для реализации вычитания единицы 
сделаем следующее. $n$ раз выполним следующее: имея пару $(n-1, n-2)$ построим пару
$(n, n-1)$. Тогда после $n$ шагов во втором элементе пары будет записано число
$n-1$, которое и хочется получить.

\begin{code}
pred = \n -> snd (n (\p -> (pair (succ (fst p)) (fst p))) (pair zero zero))
\end{code}

Если вы ничего не поняли, не огорчайтесь. Ходят легенды, что Чёрч придумал
это, находясь в психиатрической лечебнице. Возможно, только там такое и можно
придумать.

\ignore{
\begin{code}

four = succ three

seven = plus three four
twentyeight = mult seven four
fiftysix = mult twentyeight two
fiftyfive = pred fiftysix
six = pred seven

main = do print $ fiftysix (+1) 0
\end{code}
}

\end{document}
